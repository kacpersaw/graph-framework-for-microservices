// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	"fmt"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"

	baseClientset "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/client/clientset/versioned"
	fakeBaseClienset "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/client/clientset/versioned/fake"
	"gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/common"
	"gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/helper"

	baseapisnexusorgv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/apis/apis.nexus.org/v1"
	baseauthenticationnexusorgv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/apis/authentication.nexus.org/v1"
	baseconfignexusorgv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/apis/config.nexus.org/v1"
	baseextensionsnexusorgv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/apis/extensions.nexus.org/v1"
	basegatewaynexusorgv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/api.git/build/apis/gateway.nexus.org/v1"
)

type Clientset struct {
	baseClient            baseClientset.Interface
	apisNexusV1           *ApisNexusV1
	extensionsNexusV1     *ExtensionsNexusV1
	authenticationNexusV1 *AuthenticationNexusV1
	configNexusV1         *ConfigNexusV1
	gatewayNexusV1        *GatewayNexusV1
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	client.apisNexusV1 = newApisNexusV1(client)
	client.extensionsNexusV1 = newExtensionsNexusV1(client)
	client.authenticationNexusV1 = newAuthenticationNexusV1(client)
	client.configNexusV1 = newConfigNexusV1(client)
	client.gatewayNexusV1 = newGatewayNexusV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.apisNexusV1 = newApisNexusV1(client)
	client.extensionsNexusV1 = newExtensionsNexusV1(client)
	client.authenticationNexusV1 = newAuthenticationNexusV1(client)
	client.configNexusV1 = newConfigNexusV1(client)
	client.gatewayNexusV1 = newGatewayNexusV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Apis() *ApisNexusV1 {
	return c.apisNexusV1
}
func (c *Clientset) Extensions() *ExtensionsNexusV1 {
	return c.extensionsNexusV1
}
func (c *Clientset) Authentication() *AuthenticationNexusV1 {
	return c.authenticationNexusV1
}
func (c *Clientset) Config() *ConfigNexusV1 {
	return c.configNexusV1
}
func (c *Clientset) Gateway() *GatewayNexusV1 {
	return c.gatewayNexusV1
}

type ApisNexusV1 struct {
	client *Clientset
}

func newApisNexusV1(client *Clientset) *ApisNexusV1 {
	return &ApisNexusV1{
		client: client,
	}
}

type ExtensionsNexusV1 struct {
	client *Clientset
}

func newExtensionsNexusV1(client *Clientset) *ExtensionsNexusV1 {
	return &ExtensionsNexusV1{
		client: client,
	}
}

type AuthenticationNexusV1 struct {
	client *Clientset
}

func newAuthenticationNexusV1(client *Clientset) *AuthenticationNexusV1 {
	return &AuthenticationNexusV1{
		client: client,
	}
}

type ConfigNexusV1 struct {
	client *Clientset
}

func newConfigNexusV1(client *Clientset) *ConfigNexusV1 {
	return &ConfigNexusV1{
		client: client,
	}
}

type GatewayNexusV1 struct {
	client *Clientset
}

func newGatewayNexusV1(client *Clientset) *GatewayNexusV1 {
	return &GatewayNexusV1{
		client: client,
	}
}

// GetApiByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ApisNexusV1) GetApiByName(ctx context.Context, hashedName string) (*ApisApi, error) {
	result, err := group.client.baseClient.
		ApisNexusV1().
		Apis().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ApisApi{
		client: group.client,
		Api:    result,
	}, nil
}

// DeleteApiByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ApisNexusV1) DeleteApiByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ApisNexusV1().
		Apis().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ConfigGvk != nil {
		err := group.client.
			Config().
			DeleteConfigByName(ctx, result.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ApisNexusV1().
		Apis().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateApiByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ApisNexusV1) CreateApiByName(ctx context.Context,
	objToCreate *baseapisnexusorgv1.Api) (*ApisApi, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ConfigGvk = nil

	result, err := group.client.baseClient.
		ApisNexusV1().
		Apis().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &ApisApi{
		client: group.client,
		Api:    result,
	}, nil
}

// UpdateApiByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ApisNexusV1) UpdateApiByName(ctx context.Context,
	objToUpdate *baseapisnexusorgv1.Api) (*ApisApi, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ApisNexusV1().
			Apis().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ApisNexusV1().
		Apis().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ApisApi{
		client: group.client,
		Api:    result,
	}, nil
}

// ListApis returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ApisNexusV1) ListApis(ctx context.Context,
	opts metav1.ListOptions) (result []*ApisApi, err error) {
	list, err := group.client.baseClient.ApisNexusV1().
		Apis().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ApisApi, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ApisApi{
			client: group.client,
			Api:    &v,
		}
	}
	return
}

type ApisApi struct {
	client *Clientset
	*baseapisnexusorgv1.Api
}

// Delete removes obj and all it's children from the database.
func (obj *ApisApi) Delete(ctx context.Context) error {
	err := obj.client.Apis().DeleteApiByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Api = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ApisApi) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		ApisNexusV1().
		Apis().
		Update(ctx, obj.Api, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.Api = result
	return nil
}

func (c *Clientset) ApisApi(displayName string) *apiApisNexusV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["apis.apis.nexus.org"] = displayName
	return &apiApisNexusV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// GetApisApi calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetApisApi(ctx context.Context, displayName string) (result *ApisApi, err error) {
	hashedName := helper.GetHashedName("apis.apis.nexus.org", nil, displayName)
	return c.Apis().GetApiByName(ctx, hashedName)
}

// AddApisApi calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddApisApi(ctx context.Context,
	objToCreate *baseapisnexusorgv1.Api) (result *ApisApi, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Apis().CreateApiByName(ctx, objToCreate)
}

// DeleteApisApi calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeleteApisApi(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("apis.apis.nexus.org", nil, displayName)
	return c.Apis().DeleteApiByName(ctx, hashedName)
}

// GetConfig returns child or link of given type
func (obj *ApisApi) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	if obj.Spec.ConfigGvk != nil {
		return obj.client.Config().GetConfigByName(ctx, obj.Spec.ConfigGvk.Name)
	}
	return
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ApisApi) AddConfig(ctx context.Context,
	objToCreate *baseconfignexusorgv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["apis.apis.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["apis.apis.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Apis().GetApiByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Api = updatedObj.Api
	}
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ApisApi) DeleteConfig(ctx context.Context) (err error) {
	if obj.Spec.ConfigGvk != nil {
		err = obj.client.
			Config().DeleteConfigByName(ctx, obj.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Apis().GetApiByName(ctx, obj.GetName())
	if err == nil {
		obj.Api = updatedObj.Api
	}
	return
}

type apiApisNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *apiApisNexusV1Chainer) Config(name string) *configConfigNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.nexus.org"] = name
	return &configConfigNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *apiApisNexusV1Chainer) GetConfig(ctx context.Context, displayName string) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.nexus.org", c.parentLabels, displayName)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *apiApisNexusV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfignexusorgv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *apiApisNexusV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.nexus.org", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

// GetExtensionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ExtensionsNexusV1) GetExtensionByName(ctx context.Context, hashedName string) (*ExtensionsExtension, error) {
	result, err := group.client.baseClient.
		ExtensionsNexusV1().
		Extensions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ExtensionsExtension{
		client:    group.client,
		Extension: result,
	}, nil
}

// DeleteExtensionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ExtensionsNexusV1) DeleteExtensionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ExtensionsNexusV1().
		Extensions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		ExtensionsNexusV1().
		Extensions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/apiExtensionsGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExtensionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ExtensionsNexusV1) CreateExtensionByName(ctx context.Context,
	objToCreate *baseextensionsnexusorgv1.Extension) (*ExtensionsExtension, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		ExtensionsNexusV1().
		Extensions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/apiExtensionsGvk",
		Value: baseextensionsnexusorgv1.Child{
			Group: "extensions.nexus.org",
			Kind:  "Extension",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ExtensionsExtension{
		client:    group.client,
		Extension: result,
	}, nil
}

// UpdateExtensionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ExtensionsNexusV1) UpdateExtensionByName(ctx context.Context,
	objToUpdate *baseextensionsnexusorgv1.Extension) (*ExtensionsExtension, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ExtensionsNexusV1().
			Extensions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueUri :=
		objToUpdate.Spec.Uri
	patchOpUri := PatchOp{
		Op:    "replace",
		Path:  "/spec/uri",
		Value: patchValueUri,
	}
	patch = append(patch, patchOpUri)

	patchValueService :=
		objToUpdate.Spec.Service
	patchOpService := PatchOp{
		Op:    "replace",
		Path:  "/spec/service",
		Value: patchValueService,
	}
	patch = append(patch, patchOpService)

	patchValueResource :=
		objToUpdate.Spec.Resource
	patchOpResource := PatchOp{
		Op:    "replace",
		Path:  "/spec/resource",
		Value: patchValueResource,
	}
	patch = append(patch, patchOpResource)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ExtensionsNexusV1().
		Extensions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ExtensionsExtension{
		client:    group.client,
		Extension: result,
	}, nil
}

// ListExtensions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ExtensionsNexusV1) ListExtensions(ctx context.Context,
	opts metav1.ListOptions) (result []*ExtensionsExtension, err error) {
	list, err := group.client.baseClient.ExtensionsNexusV1().
		Extensions().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ExtensionsExtension, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ExtensionsExtension{
			client:    group.client,
			Extension: &v,
		}
	}
	return
}

type ExtensionsExtension struct {
	client *Clientset
	*baseextensionsnexusorgv1.Extension
}

// Delete removes obj and all it's children from the database.
func (obj *ExtensionsExtension) Delete(ctx context.Context) error {
	err := obj.client.Extensions().DeleteExtensionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Extension = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ExtensionsExtension) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		ExtensionsNexusV1().
		Extensions().
		Update(ctx, obj.Extension, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.Extension = result
	return nil
}

type extensionExtensionsNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetOIDCByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *AuthenticationNexusV1) GetOIDCByName(ctx context.Context, hashedName string) (*AuthenticationOIDC, error) {
	result, err := group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &AuthenticationOIDC{
		client: group.client,
		OIDC:   result,
	}, nil
}

// DeleteOIDCByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *AuthenticationNexusV1) DeleteOIDCByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/authNGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateOIDCByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *AuthenticationNexusV1) CreateOIDCByName(ctx context.Context,
	objToCreate *baseauthenticationnexusorgv1.OIDC) (*AuthenticationOIDC, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"authNGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"OIDC\", \"group\": \"authentication.nexus.org\"}}}}"
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &AuthenticationOIDC{
		client: group.client,
		OIDC:   result,
	}, nil
}

// UpdateOIDCByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *AuthenticationNexusV1) UpdateOIDCByName(ctx context.Context,
	objToUpdate *baseauthenticationnexusorgv1.OIDC) (*AuthenticationOIDC, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			AuthenticationNexusV1().
			OIDCs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &AuthenticationOIDC{
		client: group.client,
		OIDC:   result,
	}, nil
}

// ListOIDCs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *AuthenticationNexusV1) ListOIDCs(ctx context.Context,
	opts metav1.ListOptions) (result []*AuthenticationOIDC, err error) {
	list, err := group.client.baseClient.AuthenticationNexusV1().
		OIDCs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*AuthenticationOIDC, len(list.Items))
	for k, v := range list.Items {
		result[k] = &AuthenticationOIDC{
			client: group.client,
			OIDC:   &v,
		}
	}
	return
}

type AuthenticationOIDC struct {
	client *Clientset
	*baseauthenticationnexusorgv1.OIDC
}

// Delete removes obj and all it's children from the database.
func (obj *AuthenticationOIDC) Delete(ctx context.Context) error {
	err := obj.client.Authentication().DeleteOIDCByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.OIDC = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *AuthenticationOIDC) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().
		Update(ctx, obj.OIDC, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.OIDC = result
	return nil
}

type oidcAuthenticationNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigNexusV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	result, err := group.client.baseClient.
		ConfigNexusV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigNexusV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConfigNexusV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.GatewayGvk != nil {
		err := group.client.
			Gateway().
			DeleteGatewayByName(ctx, result.Spec.GatewayGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ApiExtensionsGvk != nil {
		err := group.client.
			Apiextensions().
			DeleteExtensionByName(ctx, result.Spec.ApiExtensionsGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AuthNGvk {
		err := group.client.
			Authn().DeleteOIDCByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/configGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["apis.apis.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("apis.apis.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ApisNexusV1().
		Apis().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigNexusV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfignexusorgv1.Config) (*ConfigConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GatewayGvk = nil
	objToCreate.Spec.ApiExtensionsGvk = nil
	objToCreate.Spec.AuthNGvk = nil

	result, err := group.client.baseClient.
		ConfigNexusV1().
		Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["apis.apis.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("apis.apis.nexus.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/configGvk",
		Value: baseconfignexusorgv1.Child{
			Group: "config.nexus.org",
			Kind:  "Config",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ApisNexusV1().
		Apis().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigNexusV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfignexusorgv1.Config) (*ConfigConfig, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConfigNexusV1().
			Configs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigNexusV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	list, err := group.client.baseClient.ConfigNexusV1().
		Configs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ConfigConfig, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ConfigConfig{
			client: group.client,
			Config: &v,
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfignexusorgv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		ConfigNexusV1().
		Configs().
		Update(ctx, obj.Config, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.Config = result
	return nil
}

// GetGateway returns child or link of given type
func (obj *ConfigConfig) GetGateway(ctx context.Context) (
	result *GatewayGateway, err error) {
	if obj.Spec.GatewayGvk != nil {
		return obj.client.Gateway().GetGatewayByName(ctx, obj.Spec.GatewayGvk.Name)
	}
	return
}

// GetApiExtensions returns child or link of given type
func (obj *ConfigConfig) GetApiExtensions(ctx context.Context) (
	result *ApiextensionsExtension, err error) {
	if obj.Spec.ApiExtensionsGvk != nil {
		return obj.client.Apiextensions().GetExtensionByName(ctx, obj.Spec.ApiExtensionsGvk.Name)
	}
	return
}

// GetAllAuthN returns all links or children of given type
func (obj *ConfigConfig) GetAllAuthN(ctx context.Context) (
	result []*AuthnOIDC, err error) {
	result = make([]*AuthnOIDC, 0, len(obj.Spec.AuthNGvk))
	for _, v := range obj.Spec.AuthNGvk {
		l, err := obj.client.Authn().GetOIDCByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAuthN returns link or child which has given displayName
func (obj *ConfigConfig) GetAuthN(ctx context.Context,
	displayName string) (result *AuthnOIDC, err error) {
	l, ok := obj.Spec.AuthNGvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.Authn().GetOIDCByName(ctx, l.Name)
	return
}

// AddGateway calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddGateway(ctx context.Context,
	objToCreate *basegatewaynexusorgv1.Gateway) (result *GatewayGateway, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gateway().CreateGatewayByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteGateway calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteGateway(ctx context.Context) (err error) {
	if obj.Spec.GatewayGvk != nil {
		err = obj.client.
			Gateway().DeleteGatewayByName(ctx, obj.Spec.GatewayGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// AddApiExtensions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddApiExtensions(ctx context.Context,
	objToCreate *baseapiextensionsnexusorgv1.Extension) (result *ApiextensionsExtension, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Apiextensions().CreateExtensionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteApiExtensions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteApiExtensions(ctx context.Context) (err error) {
	if obj.Spec.ApiExtensionsGvk != nil {
		err = obj.client.
			Apiextensions().DeleteExtensionByName(ctx, obj.Spec.ApiExtensionsGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// AddAuthN calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddAuthN(ctx context.Context,
	objToCreate *baseauthnnexusorgv1.OIDC) (result *AuthnOIDC, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Authn().CreateOIDCByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteAuthN calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteAuthN(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AuthNGvk[displayName]
	if !ok {
		return fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	err = obj.client.Authn().DeleteOIDCByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configConfigNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigNexusV1Chainer) Gateway(name string) *gatewayGatewayNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gateways.gateway.nexus.org"] = name
	return &gatewayGatewayNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGateway calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigNexusV1Chainer) GetGateway(ctx context.Context, displayName string) (result *GatewayGateway, err error) {
	hashedName := helper.GetHashedName("gateways.gateway.nexus.org", c.parentLabels, displayName)
	return c.client.Gateway().GetGatewayByName(ctx, hashedName)
}

// AddGateway calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigNexusV1Chainer) AddGateway(ctx context.Context,
	objToCreate *basegatewaynexusorgv1.Gateway) (result *GatewayGateway, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gateways.gateway.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gateway().CreateGatewayByName(ctx, objToCreate)
}

// DeleteGateway calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigNexusV1Chainer) DeleteGateway(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gateways.gateway.nexus.org", c.parentLabels, name)
	return c.client.Gateway().DeleteGatewayByName(ctx, hashedName)
}

func (c *configConfigNexusV1Chainer) ApiExtensions(name string) *extensionApiextensionsNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["extensions.apiextensions.nexus.org"] = name
	return &extensionApiextensionsNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetApiExtensions calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigNexusV1Chainer) GetApiExtensions(ctx context.Context, displayName string) (result *ApiextensionsExtension, err error) {
	hashedName := helper.GetHashedName("extensions.apiextensions.nexus.org", c.parentLabels, displayName)
	return c.client.Apiextensions().GetExtensionByName(ctx, hashedName)
}

// AddApiExtensions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigNexusV1Chainer) AddApiExtensions(ctx context.Context,
	objToCreate *baseapiextensionsnexusorgv1.Extension) (result *ApiextensionsExtension, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("extensions.apiextensions.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Apiextensions().CreateExtensionByName(ctx, objToCreate)
}

// DeleteApiExtensions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigNexusV1Chainer) DeleteApiExtensions(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("extensions.apiextensions.nexus.org", c.parentLabels, name)
	return c.client.Apiextensions().DeleteExtensionByName(ctx, hashedName)
}

func (c *configConfigNexusV1Chainer) AuthN(name string) *oidcAuthnNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["oidcs.authn.nexus.org"] = name
	return &oidcAuthnNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAuthN calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigNexusV1Chainer) GetAuthN(ctx context.Context, displayName string) (result *AuthnOIDC, err error) {
	hashedName := helper.GetHashedName("oidcs.authn.nexus.org", c.parentLabels, displayName)
	return c.client.Authn().GetOIDCByName(ctx, hashedName)
}

// AddAuthN calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigNexusV1Chainer) AddAuthN(ctx context.Context,
	objToCreate *baseauthnnexusorgv1.OIDC) (result *AuthnOIDC, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("oidcs.authn.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Authn().CreateOIDCByName(ctx, objToCreate)
}

// DeleteAuthN calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigNexusV1Chainer) DeleteAuthN(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("oidcs.authn.nexus.org", c.parentLabels, name)
	return c.client.Authn().DeleteOIDCByName(ctx, hashedName)
}

// GetGatewayByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GatewayNexusV1) GetGatewayByName(ctx context.Context, hashedName string) (*GatewayGateway, error) {
	result, err := group.client.baseClient.
		GatewayNexusV1().
		Gateways().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &GatewayGateway{
		client:  group.client,
		Gateway: result,
	}, nil
}

// DeleteGatewayByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GatewayNexusV1) DeleteGatewayByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GatewayNexusV1().
		Gateways().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GatewayNexusV1().
		Gateways().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gatewayGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGatewayByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GatewayNexusV1) CreateGatewayByName(ctx context.Context,
	objToCreate *basegatewaynexusorgv1.Gateway) (*GatewayGateway, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AuthnGvk = nil

	result, err := group.client.baseClient.
		GatewayNexusV1().
		Gateways().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/gatewayGvk",
		Value: basegatewaynexusorgv1.Child{
			Group: "gateway.nexus.org",
			Kind:  "Gateway",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GatewayGateway{
		client:  group.client,
		Gateway: result,
	}, nil
}

// UpdateGatewayByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GatewayNexusV1) UpdateGatewayByName(ctx context.Context,
	objToUpdate *basegatewaynexusorgv1.Gateway) (*GatewayGateway, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GatewayNexusV1().
			Gateways().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GatewayNexusV1().
		Gateways().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GatewayGateway{
		client:  group.client,
		Gateway: result,
	}, nil
}

// ListGateways returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GatewayNexusV1) ListGateways(ctx context.Context,
	opts metav1.ListOptions) (result []*GatewayGateway, err error) {
	list, err := group.client.baseClient.GatewayNexusV1().
		Gateways().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*GatewayGateway, len(list.Items))
	for k, v := range list.Items {
		result[k] = &GatewayGateway{
			client:  group.client,
			Gateway: &v,
		}
	}
	return
}

type GatewayGateway struct {
	client *Clientset
	*basegatewaynexusorgv1.Gateway
}

// Delete removes obj and all it's children from the database.
func (obj *GatewayGateway) Delete(ctx context.Context) error {
	err := obj.client.Gateway().DeleteGatewayByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Gateway = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GatewayGateway) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		GatewayNexusV1().
		Gateways().
		Update(ctx, obj.Gateway, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.Gateway = result
	return nil
}

// GetAuthn returns child or link of given type
func (obj *GatewayGateway) GetAuthn(ctx context.Context) (
	result *AuthnOIDC, err error) {
	if obj.Spec.AuthnGvk != nil {
		return obj.client.Authn().GetOIDCByName(ctx, obj.Spec.AuthnGvk.Name)
	}
	return
}

// LinkAuthn links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GatewayGateway) LinkAuthn(ctx context.Context,
	linkToAdd *AuthnOIDC) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/authnGvk",
		Value: basegatewaynexusorgv1.Child{
			Group: "authn.nexus.org",
			Kind:  "OIDC",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GatewayNexusV1().Gateways().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Gateway = result
	return nil
}

// UnlinkAuthn unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GatewayGateway) UnlinkAuthn(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/authnGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GatewayNexusV1().Gateways().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Gateway = result
	return nil

}

type gatewayGatewayNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}
