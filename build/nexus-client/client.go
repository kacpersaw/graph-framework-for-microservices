// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	"fmt"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"

	baseClientset "golang-appnet.eng.vmware.com/nexus-sdk/api/build/client/clientset/versioned"
	fakeBaseClienset "golang-appnet.eng.vmware.com/nexus-sdk/api/build/client/clientset/versioned/fake"
	"golang-appnet.eng.vmware.com/nexus-sdk/api/build/common"
	"golang-appnet.eng.vmware.com/nexus-sdk/api/build/helper"

	baseapinexusorgv1 "golang-appnet.eng.vmware.com/nexus-sdk/api/build/apis/api.nexus.org/v1"
	baseapigatewaynexusorgv1 "golang-appnet.eng.vmware.com/nexus-sdk/api/build/apis/apigateway.nexus.org/v1"
	baseauthenticationnexusorgv1 "golang-appnet.eng.vmware.com/nexus-sdk/api/build/apis/authentication.nexus.org/v1"
	baseconfignexusorgv1 "golang-appnet.eng.vmware.com/nexus-sdk/api/build/apis/config.nexus.org/v1"
	baseconnectnexusorgv1 "golang-appnet.eng.vmware.com/nexus-sdk/api/build/apis/connect.nexus.org/v1"
	baseroutenexusorgv1 "golang-appnet.eng.vmware.com/nexus-sdk/api/build/apis/route.nexus.org/v1"
)

type Clientset struct {
	baseClient            baseClientset.Interface
	apiNexusV1            *ApiNexusV1
	apigatewayNexusV1     *ApigatewayNexusV1
	authenticationNexusV1 *AuthenticationNexusV1
	configNexusV1         *ConfigNexusV1
	connectNexusV1        *ConnectNexusV1
	routeNexusV1          *RouteNexusV1
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	client.apiNexusV1 = newApiNexusV1(client)
	client.apigatewayNexusV1 = newApigatewayNexusV1(client)
	client.authenticationNexusV1 = newAuthenticationNexusV1(client)
	client.configNexusV1 = newConfigNexusV1(client)
	client.connectNexusV1 = newConnectNexusV1(client)
	client.routeNexusV1 = newRouteNexusV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.apiNexusV1 = newApiNexusV1(client)
	client.apigatewayNexusV1 = newApigatewayNexusV1(client)
	client.authenticationNexusV1 = newAuthenticationNexusV1(client)
	client.configNexusV1 = newConfigNexusV1(client)
	client.connectNexusV1 = newConnectNexusV1(client)
	client.routeNexusV1 = newRouteNexusV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Api() *ApiNexusV1 {
	return c.apiNexusV1
}
func (c *Clientset) Apigateway() *ApigatewayNexusV1 {
	return c.apigatewayNexusV1
}
func (c *Clientset) Authentication() *AuthenticationNexusV1 {
	return c.authenticationNexusV1
}
func (c *Clientset) Config() *ConfigNexusV1 {
	return c.configNexusV1
}
func (c *Clientset) Connect() *ConnectNexusV1 {
	return c.connectNexusV1
}
func (c *Clientset) Route() *RouteNexusV1 {
	return c.routeNexusV1
}

type ApiNexusV1 struct {
	client *Clientset
}

func newApiNexusV1(client *Clientset) *ApiNexusV1 {
	return &ApiNexusV1{
		client: client,
	}
}

type ApigatewayNexusV1 struct {
	client *Clientset
}

func newApigatewayNexusV1(client *Clientset) *ApigatewayNexusV1 {
	return &ApigatewayNexusV1{
		client: client,
	}
}

type AuthenticationNexusV1 struct {
	client *Clientset
}

func newAuthenticationNexusV1(client *Clientset) *AuthenticationNexusV1 {
	return &AuthenticationNexusV1{
		client: client,
	}
}

type ConfigNexusV1 struct {
	client *Clientset
}

func newConfigNexusV1(client *Clientset) *ConfigNexusV1 {
	return &ConfigNexusV1{
		client: client,
	}
}

type ConnectNexusV1 struct {
	client *Clientset
}

func newConnectNexusV1(client *Clientset) *ConnectNexusV1 {
	return &ConnectNexusV1{
		client: client,
	}
}

type RouteNexusV1 struct {
	client *Clientset
}

func newRouteNexusV1(client *Clientset) *RouteNexusV1 {
	return &RouteNexusV1{
		client: client,
	}
}

// GetNexusByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ApiNexusV1) GetNexusByName(ctx context.Context, hashedName string) (*ApiNexus, error) {
	result, err := group.client.baseClient.
		ApiNexusV1().
		Nexuses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ApiNexus{
		client: group.client,
		Nexus:  result,
	}, nil
}

// DeleteNexusByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ApiNexusV1) DeleteNexusByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ApiNexusV1().
		Nexuses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ConfigGvk != nil {
		err := group.client.
			Config().
			DeleteConfigByName(ctx, result.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ApiNexusV1().
		Nexuses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNexusByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ApiNexusV1) CreateNexusByName(ctx context.Context,
	objToCreate *baseapinexusorgv1.Nexus) (*ApiNexus, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ConfigGvk = nil

	result, err := group.client.baseClient.
		ApiNexusV1().
		Nexuses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &ApiNexus{
		client: group.client,
		Nexus:  result,
	}, nil
}

// UpdateNexusByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ApiNexusV1) UpdateNexusByName(ctx context.Context,
	objToUpdate *baseapinexusorgv1.Nexus) (*ApiNexus, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ApiNexusV1().
			Nexuses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ApiNexusV1().
		Nexuses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ApiNexus{
		client: group.client,
		Nexus:  result,
	}, nil
}

// ListNexuses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ApiNexusV1) ListNexuses(ctx context.Context,
	opts metav1.ListOptions) (result []*ApiNexus, err error) {
	list, err := group.client.baseClient.ApiNexusV1().
		Nexuses().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ApiNexus, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ApiNexus{
			client: group.client,
			Nexus:  &v,
		}
	}
	return
}

type ApiNexus struct {
	client *Clientset
	*baseapinexusorgv1.Nexus
}

// Delete removes obj and all it's children from the database.
func (obj *ApiNexus) Delete(ctx context.Context) error {
	err := obj.client.Api().DeleteNexusByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Nexus = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ApiNexus) Update(ctx context.Context) error {
	result, err := obj.client.Api().UpdateNexusByName(ctx, obj.Nexus)
	if err != nil {
		return err
	}
	obj.Nexus = result.Nexus
	return nil
}

func (c *Clientset) ApiNexus(displayName string) *nexusApiNexusV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["nexuses.api.nexus.org"] = displayName
	return &nexusApiNexusV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// GetApiNexus calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetApiNexus(ctx context.Context, displayName string) (result *ApiNexus, err error) {
	hashedName := helper.GetHashedName("nexuses.api.nexus.org", nil, displayName)
	return c.Api().GetNexusByName(ctx, hashedName)
}

// AddApiNexus calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddApiNexus(ctx context.Context,
	objToCreate *baseapinexusorgv1.Nexus) (result *ApiNexus, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Api().CreateNexusByName(ctx, objToCreate)
}

// DeleteApiNexus calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeleteApiNexus(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("nexuses.api.nexus.org", nil, displayName)
	return c.Api().DeleteNexusByName(ctx, hashedName)
}

// GetConfig returns child or link of given type
func (obj *ApiNexus) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	if obj.Spec.ConfigGvk != nil {
		return obj.client.Config().GetConfigByName(ctx, obj.Spec.ConfigGvk.Name)
	}
	return
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ApiNexus) AddConfig(ctx context.Context,
	objToCreate *baseconfignexusorgv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["nexuses.api.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["nexuses.api.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Api().GetNexusByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Nexus = updatedObj.Nexus
	}
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ApiNexus) DeleteConfig(ctx context.Context) (err error) {
	if obj.Spec.ConfigGvk != nil {
		err = obj.client.
			Config().DeleteConfigByName(ctx, obj.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Api().GetNexusByName(ctx, obj.GetName())
	if err == nil {
		obj.Nexus = updatedObj.Nexus
	}
	return
}

type nexusApiNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *nexusApiNexusV1Chainer) Config(name string) *configConfigNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.nexus.org"] = name
	return &configConfigNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *nexusApiNexusV1Chainer) GetConfig(ctx context.Context, displayName string) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.nexus.org", c.parentLabels, displayName)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *nexusApiNexusV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfignexusorgv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *nexusApiNexusV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.nexus.org", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

// GetApiGatewayByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ApigatewayNexusV1) GetApiGatewayByName(ctx context.Context, hashedName string) (*ApigatewayApiGateway, error) {
	result, err := group.client.baseClient.
		ApigatewayNexusV1().
		ApiGateways().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ApigatewayApiGateway{
		client:     group.client,
		ApiGateway: result,
	}, nil
}

// DeleteApiGatewayByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ApigatewayNexusV1) DeleteApiGatewayByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ApigatewayNexusV1().
		ApiGateways().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.AuthnGvk != nil {
		err := group.client.
			Authentication().
			DeleteOIDCByName(ctx, result.Spec.AuthnGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ApigatewayNexusV1().
		ApiGateways().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/apiGatewayGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateApiGatewayByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ApigatewayNexusV1) CreateApiGatewayByName(ctx context.Context,
	objToCreate *baseapigatewaynexusorgv1.ApiGateway) (*ApigatewayApiGateway, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AuthnGvk = nil

	result, err := group.client.baseClient.
		ApigatewayNexusV1().
		ApiGateways().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/apiGatewayGvk",
		Value: baseapigatewaynexusorgv1.Child{
			Group: "apigateway.nexus.org",
			Kind:  "ApiGateway",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ApigatewayApiGateway{
		client:     group.client,
		ApiGateway: result,
	}, nil
}

// UpdateApiGatewayByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ApigatewayNexusV1) UpdateApiGatewayByName(ctx context.Context,
	objToUpdate *baseapigatewaynexusorgv1.ApiGateway) (*ApigatewayApiGateway, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ApigatewayNexusV1().
			ApiGateways().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ApigatewayNexusV1().
		ApiGateways().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ApigatewayApiGateway{
		client:     group.client,
		ApiGateway: result,
	}, nil
}

// ListApiGateways returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ApigatewayNexusV1) ListApiGateways(ctx context.Context,
	opts metav1.ListOptions) (result []*ApigatewayApiGateway, err error) {
	list, err := group.client.baseClient.ApigatewayNexusV1().
		ApiGateways().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ApigatewayApiGateway, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ApigatewayApiGateway{
			client:     group.client,
			ApiGateway: &v,
		}
	}
	return
}

type ApigatewayApiGateway struct {
	client *Clientset
	*baseapigatewaynexusorgv1.ApiGateway
}

// Delete removes obj and all it's children from the database.
func (obj *ApigatewayApiGateway) Delete(ctx context.Context) error {
	err := obj.client.Apigateway().DeleteApiGatewayByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ApiGateway = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ApigatewayApiGateway) Update(ctx context.Context) error {
	result, err := obj.client.Apigateway().UpdateApiGatewayByName(ctx, obj.ApiGateway)
	if err != nil {
		return err
	}
	obj.ApiGateway = result.ApiGateway
	return nil
}

func (obj *ApigatewayApiGateway) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.nexus.org", obj.Labels, obj.Labels["configs.config.nexus.org"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

// GetAuthn returns child or link of given type
func (obj *ApigatewayApiGateway) GetAuthn(ctx context.Context) (
	result *AuthenticationOIDC, err error) {
	if obj.Spec.AuthnGvk != nil {
		return obj.client.Authentication().GetOIDCByName(ctx, obj.Spec.AuthnGvk.Name)
	}
	return
}

// AddAuthn calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ApigatewayApiGateway) AddAuthn(ctx context.Context,
	objToCreate *baseauthenticationnexusorgv1.OIDC) (result *AuthenticationOIDC, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["apigateways.apigateway.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["apigateways.apigateway.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Authentication().CreateOIDCByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Apigateway().GetApiGatewayByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ApiGateway = updatedObj.ApiGateway
	}
	return
}

// DeleteAuthn calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ApigatewayApiGateway) DeleteAuthn(ctx context.Context) (err error) {
	if obj.Spec.AuthnGvk != nil {
		err = obj.client.
			Authentication().DeleteOIDCByName(ctx, obj.Spec.AuthnGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Apigateway().GetApiGatewayByName(ctx, obj.GetName())
	if err == nil {
		obj.ApiGateway = updatedObj.ApiGateway
	}
	return
}

type apigatewayApigatewayNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *apigatewayApigatewayNexusV1Chainer) Authn(name string) *oidcAuthenticationNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["oidcs.authentication.nexus.org"] = name
	return &oidcAuthenticationNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAuthn calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *apigatewayApigatewayNexusV1Chainer) GetAuthn(ctx context.Context, displayName string) (result *AuthenticationOIDC, err error) {
	hashedName := helper.GetHashedName("oidcs.authentication.nexus.org", c.parentLabels, displayName)
	return c.client.Authentication().GetOIDCByName(ctx, hashedName)
}

// AddAuthn calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *apigatewayApigatewayNexusV1Chainer) AddAuthn(ctx context.Context,
	objToCreate *baseauthenticationnexusorgv1.OIDC) (result *AuthenticationOIDC, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("oidcs.authentication.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Authentication().CreateOIDCByName(ctx, objToCreate)
}

// DeleteAuthn calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *apigatewayApigatewayNexusV1Chainer) DeleteAuthn(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("oidcs.authentication.nexus.org", c.parentLabels, name)
	return c.client.Authentication().DeleteOIDCByName(ctx, hashedName)
}

// GetOIDCByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *AuthenticationNexusV1) GetOIDCByName(ctx context.Context, hashedName string) (*AuthenticationOIDC, error) {
	result, err := group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &AuthenticationOIDC{
		client: group.client,
		OIDC:   result,
	}, nil
}

// DeleteOIDCByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *AuthenticationNexusV1) DeleteOIDCByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/authnGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["apigateways.apigateway.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("apigateways.apigateway.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ApigatewayNexusV1().
		ApiGateways().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateOIDCByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *AuthenticationNexusV1) CreateOIDCByName(ctx context.Context,
	objToCreate *baseauthenticationnexusorgv1.OIDC) (*AuthenticationOIDC, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["apigateways.apigateway.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("apigateways.apigateway.nexus.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/authnGvk",
		Value: baseauthenticationnexusorgv1.Child{
			Group: "authentication.nexus.org",
			Kind:  "OIDC",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ApigatewayNexusV1().
		ApiGateways().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &AuthenticationOIDC{
		client: group.client,
		OIDC:   result,
	}, nil
}

// UpdateOIDCByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *AuthenticationNexusV1) UpdateOIDCByName(ctx context.Context,
	objToUpdate *baseauthenticationnexusorgv1.OIDC) (*AuthenticationOIDC, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			AuthenticationNexusV1().
			OIDCs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	patchValueValidationProps :=
		objToUpdate.Spec.ValidationProps
	patchOpValidationProps := PatchOp{
		Op:    "replace",
		Path:  "/spec/validationProps",
		Value: patchValueValidationProps,
	}
	patch = append(patch, patchOpValidationProps)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		AuthenticationNexusV1().
		OIDCs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &AuthenticationOIDC{
		client: group.client,
		OIDC:   result,
	}, nil
}

// ListOIDCs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *AuthenticationNexusV1) ListOIDCs(ctx context.Context,
	opts metav1.ListOptions) (result []*AuthenticationOIDC, err error) {
	list, err := group.client.baseClient.AuthenticationNexusV1().
		OIDCs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*AuthenticationOIDC, len(list.Items))
	for k, v := range list.Items {
		result[k] = &AuthenticationOIDC{
			client: group.client,
			OIDC:   &v,
		}
	}
	return
}

type AuthenticationOIDC struct {
	client *Clientset
	*baseauthenticationnexusorgv1.OIDC
}

// Delete removes obj and all it's children from the database.
func (obj *AuthenticationOIDC) Delete(ctx context.Context) error {
	err := obj.client.Authentication().DeleteOIDCByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.OIDC = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *AuthenticationOIDC) Update(ctx context.Context) error {
	result, err := obj.client.Authentication().UpdateOIDCByName(ctx, obj.OIDC)
	if err != nil {
		return err
	}
	obj.OIDC = result.OIDC
	return nil
}

func (obj *AuthenticationOIDC) GetParent(ctx context.Context) (result *ApigatewayApiGateway, err error) {
	hashedName := helper.GetHashedName("apigateways.apigateway.nexus.org", obj.Labels, obj.Labels["apigateways.apigateway.nexus.org"])
	return obj.client.Apigateway().GetApiGatewayByName(ctx, hashedName)
}

type oidcAuthenticationNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigNexusV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	result, err := group.client.baseClient.
		ConfigNexusV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigNexusV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConfigNexusV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ApiGatewayGvk != nil {
		err := group.client.
			Apigateway().
			DeleteApiGatewayByName(ctx, result.Spec.ApiGatewayGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.RoutesGvk {
		err := group.client.
			Route().DeleteRouteByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ConnectGvk != nil {
		err := group.client.
			Connect().
			DeleteConnectByName(ctx, result.Spec.ConnectGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/configGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["nexuses.api.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("nexuses.api.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ApiNexusV1().
		Nexuses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigNexusV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfignexusorgv1.Config) (*ConfigConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ApiGatewayGvk = nil
	objToCreate.Spec.RoutesGvk = nil
	objToCreate.Spec.ConnectGvk = nil

	result, err := group.client.baseClient.
		ConfigNexusV1().
		Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["nexuses.api.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("nexuses.api.nexus.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/configGvk",
		Value: baseconfignexusorgv1.Child{
			Group: "config.nexus.org",
			Kind:  "Config",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ApiNexusV1().
		Nexuses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigNexusV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfignexusorgv1.Config) (*ConfigConfig, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConfigNexusV1().
			Configs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigNexusV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	list, err := group.client.baseClient.ConfigNexusV1().
		Configs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ConfigConfig, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ConfigConfig{
			client: group.client,
			Config: &v,
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfignexusorgv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *ConfigConfig) GetParent(ctx context.Context) (result *ApiNexus, err error) {
	hashedName := helper.GetHashedName("nexuses.api.nexus.org", obj.Labels, obj.Labels["nexuses.api.nexus.org"])
	return obj.client.Api().GetNexusByName(ctx, hashedName)
}

// GetApiGateway returns child or link of given type
func (obj *ConfigConfig) GetApiGateway(ctx context.Context) (
	result *ApigatewayApiGateway, err error) {
	if obj.Spec.ApiGatewayGvk != nil {
		return obj.client.Apigateway().GetApiGatewayByName(ctx, obj.Spec.ApiGatewayGvk.Name)
	}
	return
}

// GetAllRoutes returns all links or children of given type
func (obj *ConfigConfig) GetAllRoutes(ctx context.Context) (
	result []*RouteRoute, err error) {
	result = make([]*RouteRoute, 0, len(obj.Spec.RoutesGvk))
	for _, v := range obj.Spec.RoutesGvk {
		l, err := obj.client.Route().GetRouteByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetRoutes returns link or child which has given displayName
func (obj *ConfigConfig) GetRoutes(ctx context.Context,
	displayName string) (result *RouteRoute, err error) {
	l, ok := obj.Spec.RoutesGvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.Route().GetRouteByName(ctx, l.Name)
	return
}

// GetConnect returns child or link of given type
func (obj *ConfigConfig) GetConnect(ctx context.Context) (
	result *ConnectConnect, err error) {
	if obj.Spec.ConnectGvk != nil {
		return obj.client.Connect().GetConnectByName(ctx, obj.Spec.ConnectGvk.Name)
	}
	return
}

// AddApiGateway calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddApiGateway(ctx context.Context,
	objToCreate *baseapigatewaynexusorgv1.ApiGateway) (result *ApigatewayApiGateway, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Apigateway().CreateApiGatewayByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteApiGateway calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteApiGateway(ctx context.Context) (err error) {
	if obj.Spec.ApiGatewayGvk != nil {
		err = obj.client.
			Apigateway().DeleteApiGatewayByName(ctx, obj.Spec.ApiGatewayGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// AddRoutes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddRoutes(ctx context.Context,
	objToCreate *baseroutenexusorgv1.Route) (result *RouteRoute, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Route().CreateRouteByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteRoutes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteRoutes(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.RoutesGvk[displayName]
	if !ok {
		return fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	err = obj.client.Route().DeleteRouteByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// AddConnect calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddConnect(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.Connect) (result *ConnectConnect, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Connect().CreateConnectByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteConnect calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteConnect(ctx context.Context) (err error) {
	if obj.Spec.ConnectGvk != nil {
		err = obj.client.
			Connect().DeleteConnectByName(ctx, obj.Spec.ConnectGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configConfigNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigNexusV1Chainer) ApiGateway(name string) *apigatewayApigatewayNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["apigateways.apigateway.nexus.org"] = name
	return &apigatewayApigatewayNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetApiGateway calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigNexusV1Chainer) GetApiGateway(ctx context.Context, displayName string) (result *ApigatewayApiGateway, err error) {
	hashedName := helper.GetHashedName("apigateways.apigateway.nexus.org", c.parentLabels, displayName)
	return c.client.Apigateway().GetApiGatewayByName(ctx, hashedName)
}

// AddApiGateway calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigNexusV1Chainer) AddApiGateway(ctx context.Context,
	objToCreate *baseapigatewaynexusorgv1.ApiGateway) (result *ApigatewayApiGateway, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("apigateways.apigateway.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Apigateway().CreateApiGatewayByName(ctx, objToCreate)
}

// DeleteApiGateway calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigNexusV1Chainer) DeleteApiGateway(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("apigateways.apigateway.nexus.org", c.parentLabels, name)
	return c.client.Apigateway().DeleteApiGatewayByName(ctx, hashedName)
}

func (c *configConfigNexusV1Chainer) Routes(name string) *routeRouteNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["routes.route.nexus.org"] = name
	return &routeRouteNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetRoutes calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigNexusV1Chainer) GetRoutes(ctx context.Context, displayName string) (result *RouteRoute, err error) {
	hashedName := helper.GetHashedName("routes.route.nexus.org", c.parentLabels, displayName)
	return c.client.Route().GetRouteByName(ctx, hashedName)
}

// AddRoutes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigNexusV1Chainer) AddRoutes(ctx context.Context,
	objToCreate *baseroutenexusorgv1.Route) (result *RouteRoute, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("routes.route.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Route().CreateRouteByName(ctx, objToCreate)
}

// DeleteRoutes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigNexusV1Chainer) DeleteRoutes(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("routes.route.nexus.org", c.parentLabels, name)
	return c.client.Route().DeleteRouteByName(ctx, hashedName)
}

func (c *configConfigNexusV1Chainer) Connect(name string) *connectConnectNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["connects.connect.nexus.org"] = name
	return &connectConnectNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConnect calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigNexusV1Chainer) GetConnect(ctx context.Context, displayName string) (result *ConnectConnect, err error) {
	hashedName := helper.GetHashedName("connects.connect.nexus.org", c.parentLabels, displayName)
	return c.client.Connect().GetConnectByName(ctx, hashedName)
}

// AddConnect calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigNexusV1Chainer) AddConnect(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.Connect) (result *ConnectConnect, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("connects.connect.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Connect().CreateConnectByName(ctx, objToCreate)
}

// DeleteConnect calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigNexusV1Chainer) DeleteConnect(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("connects.connect.nexus.org", c.parentLabels, name)
	return c.client.Connect().DeleteConnectByName(ctx, hashedName)
}

// GetConnectByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConnectNexusV1) GetConnectByName(ctx context.Context, hashedName string) (*ConnectConnect, error) {
	result, err := group.client.baseClient.
		ConnectNexusV1().
		Connects().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ConnectConnect{
		client:  group.client,
		Connect: result,
	}, nil
}

// DeleteConnectByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConnectNexusV1) DeleteConnectByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConnectNexusV1().
		Connects().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.EndpointsGvk {
		err := group.client.
			Connect().DeleteNexusEndpointByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ReplicationConfigGvk {
		err := group.client.
			Connect().DeleteReplicationConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ConnectNexusV1().
		Connects().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/connectGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateConnectByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConnectNexusV1) CreateConnectByName(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.Connect) (*ConnectConnect, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.EndpointsGvk = nil
	objToCreate.Spec.ReplicationConfigGvk = nil

	result, err := group.client.baseClient.
		ConnectNexusV1().
		Connects().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/connectGvk",
		Value: baseconnectnexusorgv1.Child{
			Group: "connect.nexus.org",
			Kind:  "Connect",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConnectConnect{
		client:  group.client,
		Connect: result,
	}, nil
}

// UpdateConnectByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConnectNexusV1) UpdateConnectByName(ctx context.Context,
	objToUpdate *baseconnectnexusorgv1.Connect) (*ConnectConnect, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConnectNexusV1().
			Connects().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConnectNexusV1().
		Connects().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConnectConnect{
		client:  group.client,
		Connect: result,
	}, nil
}

// ListConnects returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConnectNexusV1) ListConnects(ctx context.Context,
	opts metav1.ListOptions) (result []*ConnectConnect, err error) {
	list, err := group.client.baseClient.ConnectNexusV1().
		Connects().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ConnectConnect, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ConnectConnect{
			client:  group.client,
			Connect: &v,
		}
	}
	return
}

type ConnectConnect struct {
	client *Clientset
	*baseconnectnexusorgv1.Connect
}

// Delete removes obj and all it's children from the database.
func (obj *ConnectConnect) Delete(ctx context.Context) error {
	err := obj.client.Connect().DeleteConnectByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Connect = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConnectConnect) Update(ctx context.Context) error {
	result, err := obj.client.Connect().UpdateConnectByName(ctx, obj.Connect)
	if err != nil {
		return err
	}
	obj.Connect = result.Connect
	return nil
}

func (obj *ConnectConnect) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.nexus.org", obj.Labels, obj.Labels["configs.config.nexus.org"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

// GetAllEndpoints returns all links or children of given type
func (obj *ConnectConnect) GetAllEndpoints(ctx context.Context) (
	result []*ConnectNexusEndpoint, err error) {
	result = make([]*ConnectNexusEndpoint, 0, len(obj.Spec.EndpointsGvk))
	for _, v := range obj.Spec.EndpointsGvk {
		l, err := obj.client.Connect().GetNexusEndpointByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEndpoints returns link or child which has given displayName
func (obj *ConnectConnect) GetEndpoints(ctx context.Context,
	displayName string) (result *ConnectNexusEndpoint, err error) {
	l, ok := obj.Spec.EndpointsGvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.Connect().GetNexusEndpointByName(ctx, l.Name)
	return
}

// GetAllReplicationConfig returns all links or children of given type
func (obj *ConnectConnect) GetAllReplicationConfig(ctx context.Context) (
	result []*ConnectReplicationConfig, err error) {
	result = make([]*ConnectReplicationConfig, 0, len(obj.Spec.ReplicationConfigGvk))
	for _, v := range obj.Spec.ReplicationConfigGvk {
		l, err := obj.client.Connect().GetReplicationConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetReplicationConfig returns link or child which has given displayName
func (obj *ConnectConnect) GetReplicationConfig(ctx context.Context,
	displayName string) (result *ConnectReplicationConfig, err error) {
	l, ok := obj.Spec.ReplicationConfigGvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.Connect().GetReplicationConfigByName(ctx, l.Name)
	return
}

// AddEndpoints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConnectConnect) AddEndpoints(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.NexusEndpoint) (result *ConnectNexusEndpoint, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["connects.connect.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["connects.connect.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Connect().CreateNexusEndpointByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Connect().GetConnectByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Connect = updatedObj.Connect
	}
	return
}

// DeleteEndpoints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConnectConnect) DeleteEndpoints(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.EndpointsGvk[displayName]
	if !ok {
		return fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	err = obj.client.Connect().DeleteNexusEndpointByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Connect().GetConnectByName(ctx, obj.GetName())
	if err == nil {
		obj.Connect = updatedObj.Connect
	}
	return
}

// AddReplicationConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConnectConnect) AddReplicationConfig(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.ReplicationConfig) (result *ConnectReplicationConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["connects.connect.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["connects.connect.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Connect().CreateReplicationConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Connect().GetConnectByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Connect = updatedObj.Connect
	}
	return
}

// DeleteReplicationConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConnectConnect) DeleteReplicationConfig(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ReplicationConfigGvk[displayName]
	if !ok {
		return fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	err = obj.client.Connect().DeleteReplicationConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Connect().GetConnectByName(ctx, obj.GetName())
	if err == nil {
		obj.Connect = updatedObj.Connect
	}
	return
}

type connectConnectNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *connectConnectNexusV1Chainer) Endpoints(name string) *nexusendpointConnectNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["nexusendpoints.connect.nexus.org"] = name
	return &nexusendpointConnectNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEndpoints calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *connectConnectNexusV1Chainer) GetEndpoints(ctx context.Context, displayName string) (result *ConnectNexusEndpoint, err error) {
	hashedName := helper.GetHashedName("nexusendpoints.connect.nexus.org", c.parentLabels, displayName)
	return c.client.Connect().GetNexusEndpointByName(ctx, hashedName)
}

// AddEndpoints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *connectConnectNexusV1Chainer) AddEndpoints(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.NexusEndpoint) (result *ConnectNexusEndpoint, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("nexusendpoints.connect.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Connect().CreateNexusEndpointByName(ctx, objToCreate)
}

// DeleteEndpoints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *connectConnectNexusV1Chainer) DeleteEndpoints(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("nexusendpoints.connect.nexus.org", c.parentLabels, name)
	return c.client.Connect().DeleteNexusEndpointByName(ctx, hashedName)
}

func (c *connectConnectNexusV1Chainer) ReplicationConfig(name string) *replicationconfigConnectNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["replicationconfigs.connect.nexus.org"] = name
	return &replicationconfigConnectNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetReplicationConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *connectConnectNexusV1Chainer) GetReplicationConfig(ctx context.Context, displayName string) (result *ConnectReplicationConfig, err error) {
	hashedName := helper.GetHashedName("replicationconfigs.connect.nexus.org", c.parentLabels, displayName)
	return c.client.Connect().GetReplicationConfigByName(ctx, hashedName)
}

// AddReplicationConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *connectConnectNexusV1Chainer) AddReplicationConfig(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.ReplicationConfig) (result *ConnectReplicationConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("replicationconfigs.connect.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Connect().CreateReplicationConfigByName(ctx, objToCreate)
}

// DeleteReplicationConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *connectConnectNexusV1Chainer) DeleteReplicationConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("replicationconfigs.connect.nexus.org", c.parentLabels, name)
	return c.client.Connect().DeleteReplicationConfigByName(ctx, hashedName)
}

// GetNexusEndpointByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConnectNexusV1) GetNexusEndpointByName(ctx context.Context, hashedName string) (*ConnectNexusEndpoint, error) {
	result, err := group.client.baseClient.
		ConnectNexusV1().
		NexusEndpoints().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ConnectNexusEndpoint{
		client:        group.client,
		NexusEndpoint: result,
	}, nil
}

// DeleteNexusEndpointByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConnectNexusV1) DeleteNexusEndpointByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConnectNexusV1().
		NexusEndpoints().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		ConnectNexusV1().
		NexusEndpoints().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/endpointsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["connects.connect.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("connects.connect.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConnectNexusV1().
		Connects().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNexusEndpointByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConnectNexusV1) CreateNexusEndpointByName(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.NexusEndpoint) (*ConnectNexusEndpoint, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		ConnectNexusV1().
		NexusEndpoints().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["connects.connect.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("connects.connect.nexus.org", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"endpointsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"NexusEndpoint\", \"group\": \"connect.nexus.org\"}}}}"
	_, err = group.client.baseClient.
		ConnectNexusV1().
		Connects().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConnectNexusEndpoint{
		client:        group.client,
		NexusEndpoint: result,
	}, nil
}

// UpdateNexusEndpointByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConnectNexusV1) UpdateNexusEndpointByName(ctx context.Context,
	objToUpdate *baseconnectnexusorgv1.NexusEndpoint) (*ConnectNexusEndpoint, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConnectNexusV1().
			NexusEndpoints().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueHost :=
		objToUpdate.Spec.Host
	patchOpHost := PatchOp{
		Op:    "replace",
		Path:  "/spec/host",
		Value: patchValueHost,
	}
	patch = append(patch, patchOpHost)

	patchValuePort :=
		objToUpdate.Spec.Port
	patchOpPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/port",
		Value: patchValuePort,
	}
	patch = append(patch, patchOpPort)

	patchValueCert :=
		objToUpdate.Spec.Cert
	patchOpCert := PatchOp{
		Op:    "replace",
		Path:  "/spec/cert",
		Value: patchValueCert,
	}
	patch = append(patch, patchOpCert)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConnectNexusV1().
		NexusEndpoints().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConnectNexusEndpoint{
		client:        group.client,
		NexusEndpoint: result,
	}, nil
}

// ListNexusEndpoints returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConnectNexusV1) ListNexusEndpoints(ctx context.Context,
	opts metav1.ListOptions) (result []*ConnectNexusEndpoint, err error) {
	list, err := group.client.baseClient.ConnectNexusV1().
		NexusEndpoints().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ConnectNexusEndpoint, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ConnectNexusEndpoint{
			client:        group.client,
			NexusEndpoint: &v,
		}
	}
	return
}

type ConnectNexusEndpoint struct {
	client *Clientset
	*baseconnectnexusorgv1.NexusEndpoint
}

// Delete removes obj and all it's children from the database.
func (obj *ConnectNexusEndpoint) Delete(ctx context.Context) error {
	err := obj.client.Connect().DeleteNexusEndpointByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NexusEndpoint = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConnectNexusEndpoint) Update(ctx context.Context) error {
	result, err := obj.client.Connect().UpdateNexusEndpointByName(ctx, obj.NexusEndpoint)
	if err != nil {
		return err
	}
	obj.NexusEndpoint = result.NexusEndpoint
	return nil
}

func (obj *ConnectNexusEndpoint) GetParent(ctx context.Context) (result *ConnectConnect, err error) {
	hashedName := helper.GetHashedName("connects.connect.nexus.org", obj.Labels, obj.Labels["connects.connect.nexus.org"])
	return obj.client.Connect().GetConnectByName(ctx, hashedName)
}

type nexusendpointConnectNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetReplicationConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConnectNexusV1) GetReplicationConfigByName(ctx context.Context, hashedName string) (*ConnectReplicationConfig, error) {
	result, err := group.client.baseClient.
		ConnectNexusV1().
		ReplicationConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ConnectReplicationConfig{
		client:            group.client,
		ReplicationConfig: result,
	}, nil
}

// DeleteReplicationConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConnectNexusV1) DeleteReplicationConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConnectNexusV1().
		ReplicationConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.SourceGvk != nil {
		err := group.client.
			Connect().
			DeleteReplicationObjectByName(ctx, result.Spec.SourceGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.DestinationGvk != nil {
		err := group.client.
			Connect().
			DeleteReplicationObjectByName(ctx, result.Spec.DestinationGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ConnectNexusV1().
		ReplicationConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/replicationConfigGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["connects.connect.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("connects.connect.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConnectNexusV1().
		Connects().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateReplicationConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConnectNexusV1) CreateReplicationConfigByName(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.ReplicationConfig) (*ConnectReplicationConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.SourceGvk = nil
	objToCreate.Spec.DestinationGvk = nil
	objToCreate.Spec.RemoteEndpointGvk = nil

	result, err := group.client.baseClient.
		ConnectNexusV1().
		ReplicationConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["connects.connect.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("connects.connect.nexus.org", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"replicationConfigGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ReplicationConfig\", \"group\": \"connect.nexus.org\"}}}}"
	_, err = group.client.baseClient.
		ConnectNexusV1().
		Connects().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConnectReplicationConfig{
		client:            group.client,
		ReplicationConfig: result,
	}, nil
}

// UpdateReplicationConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConnectNexusV1) UpdateReplicationConfigByName(ctx context.Context,
	objToUpdate *baseconnectnexusorgv1.ReplicationConfig) (*ConnectReplicationConfig, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConnectNexusV1().
			ReplicationConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueAccessToken :=
		objToUpdate.Spec.AccessToken
	patchOpAccessToken := PatchOp{
		Op:    "replace",
		Path:  "/spec/accessToken",
		Value: patchValueAccessToken,
	}
	patch = append(patch, patchOpAccessToken)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConnectNexusV1().
		ReplicationConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConnectReplicationConfig{
		client:            group.client,
		ReplicationConfig: result,
	}, nil
}

// ListReplicationConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConnectNexusV1) ListReplicationConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConnectReplicationConfig, err error) {
	list, err := group.client.baseClient.ConnectNexusV1().
		ReplicationConfigs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ConnectReplicationConfig, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ConnectReplicationConfig{
			client:            group.client,
			ReplicationConfig: &v,
		}
	}
	return
}

type ConnectReplicationConfig struct {
	client *Clientset
	*baseconnectnexusorgv1.ReplicationConfig
}

// Delete removes obj and all it's children from the database.
func (obj *ConnectReplicationConfig) Delete(ctx context.Context) error {
	err := obj.client.Connect().DeleteReplicationConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ReplicationConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConnectReplicationConfig) Update(ctx context.Context) error {
	result, err := obj.client.Connect().UpdateReplicationConfigByName(ctx, obj.ReplicationConfig)
	if err != nil {
		return err
	}
	obj.ReplicationConfig = result.ReplicationConfig
	return nil
}

func (obj *ConnectReplicationConfig) GetParent(ctx context.Context) (result *ConnectConnect, err error) {
	hashedName := helper.GetHashedName("connects.connect.nexus.org", obj.Labels, obj.Labels["connects.connect.nexus.org"])
	return obj.client.Connect().GetConnectByName(ctx, hashedName)
}

// GetSource returns child or link of given type
func (obj *ConnectReplicationConfig) GetSource(ctx context.Context) (
	result *ConnectReplicationObject, err error) {
	if obj.Spec.SourceGvk != nil {
		return obj.client.Connect().GetReplicationObjectByName(ctx, obj.Spec.SourceGvk.Name)
	}
	return
}

// GetDestination returns child or link of given type
func (obj *ConnectReplicationConfig) GetDestination(ctx context.Context) (
	result *ConnectReplicationObject, err error) {
	if obj.Spec.DestinationGvk != nil {
		return obj.client.Connect().GetReplicationObjectByName(ctx, obj.Spec.DestinationGvk.Name)
	}
	return
}

// GetRemoteEndpoint returns child or link of given type
func (obj *ConnectReplicationConfig) GetRemoteEndpoint(ctx context.Context) (
	result *ConnectNexusEndpoint, err error) {
	if obj.Spec.RemoteEndpointGvk != nil {
		return obj.client.Connect().GetNexusEndpointByName(ctx, obj.Spec.RemoteEndpointGvk.Name)
	}
	return
}

// AddSource calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConnectReplicationConfig) AddSource(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.ReplicationObject) (result *ConnectReplicationObject, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["replicationconfigs.connect.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["replicationconfigs.connect.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Connect().CreateReplicationObjectByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Connect().GetReplicationConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ReplicationConfig = updatedObj.ReplicationConfig
	}
	return
}

// DeleteSource calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConnectReplicationConfig) DeleteSource(ctx context.Context) (err error) {
	if obj.Spec.SourceGvk != nil {
		err = obj.client.
			Connect().DeleteReplicationObjectByName(ctx, obj.Spec.SourceGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Connect().GetReplicationConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ReplicationConfig = updatedObj.ReplicationConfig
	}
	return
}

// AddDestination calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConnectReplicationConfig) AddDestination(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.ReplicationObject) (result *ConnectReplicationObject, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["replicationconfigs.connect.nexus.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["replicationconfigs.connect.nexus.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Connect().CreateReplicationObjectByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Connect().GetReplicationConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ReplicationConfig = updatedObj.ReplicationConfig
	}
	return
}

// DeleteDestination calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConnectReplicationConfig) DeleteDestination(ctx context.Context) (err error) {
	if obj.Spec.DestinationGvk != nil {
		err = obj.client.
			Connect().DeleteReplicationObjectByName(ctx, obj.Spec.DestinationGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Connect().GetReplicationConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ReplicationConfig = updatedObj.ReplicationConfig
	}
	return
}

// LinkRemoteEndpoint links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *ConnectReplicationConfig) LinkRemoteEndpoint(ctx context.Context,
	linkToAdd *ConnectNexusEndpoint) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/remoteEndpointGvk",
		Value: baseconnectnexusorgv1.Child{
			Group: "connect.nexus.org",
			Kind:  "NexusEndpoint",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.ConnectNexusV1().ReplicationConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ReplicationConfig = result
	return nil
}

// UnlinkRemoteEndpoint unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *ConnectReplicationConfig) UnlinkRemoteEndpoint(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/remoteEndpointGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.ConnectNexusV1().ReplicationConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ReplicationConfig = result
	return nil

}

type replicationconfigConnectNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *replicationconfigConnectNexusV1Chainer) Source(name string) *replicationobjectConnectNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["replicationobjects.connect.nexus.org"] = name
	return &replicationobjectConnectNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSource calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *replicationconfigConnectNexusV1Chainer) GetSource(ctx context.Context, displayName string) (result *ConnectReplicationObject, err error) {
	hashedName := helper.GetHashedName("replicationobjects.connect.nexus.org", c.parentLabels, displayName)
	return c.client.Connect().GetReplicationObjectByName(ctx, hashedName)
}

// AddSource calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *replicationconfigConnectNexusV1Chainer) AddSource(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.ReplicationObject) (result *ConnectReplicationObject, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("replicationobjects.connect.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Connect().CreateReplicationObjectByName(ctx, objToCreate)
}

// DeleteSource calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *replicationconfigConnectNexusV1Chainer) DeleteSource(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("replicationobjects.connect.nexus.org", c.parentLabels, name)
	return c.client.Connect().DeleteReplicationObjectByName(ctx, hashedName)
}

func (c *replicationconfigConnectNexusV1Chainer) Destination(name string) *replicationobjectConnectNexusV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["replicationobjects.connect.nexus.org"] = name
	return &replicationobjectConnectNexusV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDestination calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *replicationconfigConnectNexusV1Chainer) GetDestination(ctx context.Context, displayName string) (result *ConnectReplicationObject, err error) {
	hashedName := helper.GetHashedName("replicationobjects.connect.nexus.org", c.parentLabels, displayName)
	return c.client.Connect().GetReplicationObjectByName(ctx, hashedName)
}

// AddDestination calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *replicationconfigConnectNexusV1Chainer) AddDestination(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.ReplicationObject) (result *ConnectReplicationObject, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("replicationobjects.connect.nexus.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Connect().CreateReplicationObjectByName(ctx, objToCreate)
}

// DeleteDestination calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *replicationconfigConnectNexusV1Chainer) DeleteDestination(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("replicationobjects.connect.nexus.org", c.parentLabels, name)
	return c.client.Connect().DeleteReplicationObjectByName(ctx, hashedName)
}

// GetReplicationObjectByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConnectNexusV1) GetReplicationObjectByName(ctx context.Context, hashedName string) (*ConnectReplicationObject, error) {
	result, err := group.client.baseClient.
		ConnectNexusV1().
		ReplicationObjects().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ConnectReplicationObject{
		client:            group.client,
		ReplicationObject: result,
	}, nil
}

// DeleteReplicationObjectByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConnectNexusV1) DeleteReplicationObjectByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConnectNexusV1().
		ReplicationObjects().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		ConnectNexusV1().
		ReplicationObjects().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/destinationGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["replicationconfigs.connect.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("replicationconfigs.connect.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConnectNexusV1().
		ReplicationConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateReplicationObjectByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConnectNexusV1) CreateReplicationObjectByName(ctx context.Context,
	objToCreate *baseconnectnexusorgv1.ReplicationObject) (*ConnectReplicationObject, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		ConnectNexusV1().
		ReplicationObjects().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["replicationconfigs.connect.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("replicationconfigs.connect.nexus.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/destinationGvk",
		Value: baseconnectnexusorgv1.Child{
			Group: "connect.nexus.org",
			Kind:  "ReplicationObject",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConnectNexusV1().
		ReplicationConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConnectReplicationObject{
		client:            group.client,
		ReplicationObject: result,
	}, nil
}

// UpdateReplicationObjectByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConnectNexusV1) UpdateReplicationObjectByName(ctx context.Context,
	objToUpdate *baseconnectnexusorgv1.ReplicationObject) (*ConnectReplicationObject, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConnectNexusV1().
			ReplicationObjects().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueGroup :=
		objToUpdate.Spec.Group
	patchOpGroup := PatchOp{
		Op:    "replace",
		Path:  "/spec/group",
		Value: patchValueGroup,
	}
	patch = append(patch, patchOpGroup)

	patchValueKind :=
		objToUpdate.Spec.Kind
	patchOpKind := PatchOp{
		Op:    "replace",
		Path:  "/spec/kind",
		Value: patchValueKind,
	}
	patch = append(patch, patchOpKind)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueLocalRuntime :=
		objToUpdate.Spec.LocalRuntime
	patchOpLocalRuntime := PatchOp{
		Op:    "replace",
		Path:  "/spec/localRuntime",
		Value: patchValueLocalRuntime,
	}
	patch = append(patch, patchOpLocalRuntime)

	patchValueHierarchical :=
		objToUpdate.Spec.Hierarchical
	patchOpHierarchical := PatchOp{
		Op:    "replace",
		Path:  "/spec/hierarchical",
		Value: patchValueHierarchical,
	}
	patch = append(patch, patchOpHierarchical)

	patchValueHierarchy :=
		objToUpdate.Spec.Hierarchy
	patchOpHierarchy := PatchOp{
		Op:    "replace",
		Path:  "/spec/hierarchy",
		Value: patchValueHierarchy,
	}
	patch = append(patch, patchOpHierarchy)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConnectNexusV1().
		ReplicationObjects().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConnectReplicationObject{
		client:            group.client,
		ReplicationObject: result,
	}, nil
}

// ListReplicationObjects returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConnectNexusV1) ListReplicationObjects(ctx context.Context,
	opts metav1.ListOptions) (result []*ConnectReplicationObject, err error) {
	list, err := group.client.baseClient.ConnectNexusV1().
		ReplicationObjects().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ConnectReplicationObject, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ConnectReplicationObject{
			client:            group.client,
			ReplicationObject: &v,
		}
	}
	return
}

type ConnectReplicationObject struct {
	client *Clientset
	*baseconnectnexusorgv1.ReplicationObject
}

// Delete removes obj and all it's children from the database.
func (obj *ConnectReplicationObject) Delete(ctx context.Context) error {
	err := obj.client.Connect().DeleteReplicationObjectByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ReplicationObject = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConnectReplicationObject) Update(ctx context.Context) error {
	result, err := obj.client.Connect().UpdateReplicationObjectByName(ctx, obj.ReplicationObject)
	if err != nil {
		return err
	}
	obj.ReplicationObject = result.ReplicationObject
	return nil
}

func (obj *ConnectReplicationObject) GetParent(ctx context.Context) (result *ConnectReplicationConfig, err error) {
	hashedName := helper.GetHashedName("replicationconfigs.connect.nexus.org", obj.Labels, obj.Labels["replicationconfigs.connect.nexus.org"])
	return obj.client.Connect().GetReplicationConfigByName(ctx, hashedName)
}

type replicationobjectConnectNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetRouteByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RouteNexusV1) GetRouteByName(ctx context.Context, hashedName string) (*RouteRoute, error) {
	result, err := group.client.baseClient.
		RouteNexusV1().
		Routes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &RouteRoute{
		client: group.client,
		Route:  result,
	}, nil
}

// DeleteRouteByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RouteNexusV1) DeleteRouteByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		RouteNexusV1().
		Routes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		RouteNexusV1().
		Routes().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/routesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRouteByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RouteNexusV1) CreateRouteByName(ctx context.Context,
	objToCreate *baseroutenexusorgv1.Route) (*RouteRoute, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		RouteNexusV1().
		Routes().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.nexus.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.nexus.org", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"routesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Route\", \"group\": \"route.nexus.org\"}}}}"
	_, err = group.client.baseClient.
		ConfigNexusV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &RouteRoute{
		client: group.client,
		Route:  result,
	}, nil
}

// UpdateRouteByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RouteNexusV1) UpdateRouteByName(ctx context.Context,
	objToUpdate *baseroutenexusorgv1.Route) (*RouteRoute, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			RouteNexusV1().
			Routes().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueUri :=
		objToUpdate.Spec.Uri
	patchOpUri := PatchOp{
		Op:    "replace",
		Path:  "/spec/uri",
		Value: patchValueUri,
	}
	patch = append(patch, patchOpUri)

	patchValueService :=
		objToUpdate.Spec.Service
	patchOpService := PatchOp{
		Op:    "replace",
		Path:  "/spec/service",
		Value: patchValueService,
	}
	patch = append(patch, patchOpService)

	patchValueResource :=
		objToUpdate.Spec.Resource
	patchOpResource := PatchOp{
		Op:    "replace",
		Path:  "/spec/resource",
		Value: patchValueResource,
	}
	patch = append(patch, patchOpResource)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		RouteNexusV1().
		Routes().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &RouteRoute{
		client: group.client,
		Route:  result,
	}, nil
}

// ListRoutes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RouteNexusV1) ListRoutes(ctx context.Context,
	opts metav1.ListOptions) (result []*RouteRoute, err error) {
	list, err := group.client.baseClient.RouteNexusV1().
		Routes().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*RouteRoute, len(list.Items))
	for k, v := range list.Items {
		result[k] = &RouteRoute{
			client: group.client,
			Route:  &v,
		}
	}
	return
}

type RouteRoute struct {
	client *Clientset
	*baseroutenexusorgv1.Route
}

// Delete removes obj and all it's children from the database.
func (obj *RouteRoute) Delete(ctx context.Context) error {
	err := obj.client.Route().DeleteRouteByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Route = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RouteRoute) Update(ctx context.Context) error {
	result, err := obj.client.Route().UpdateRouteByName(ctx, obj.Route)
	if err != nil {
		return err
	}
	obj.Route = result.Route
	return nil
}

func (obj *RouteRoute) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.nexus.org", obj.Labels, obj.Labels["configs.config.nexus.org"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type routeRouteNexusV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}
